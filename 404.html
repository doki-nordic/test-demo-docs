<html><header></header><body>
    


<script>

const workerScriptURL = '/docs/overlayWorker.js';
const workerScope = '/docs/1.6.0/';
const overlays = {
    '/docs/1.6.0/': '/out.ovrl',
}

let workerReg = null;
let worker = null;
let workerResponseListener = null;

async function getWorker() {
    if (worker) return worker;
    while (!workerReg || !workerReg.active || !workerReg.active.scriptURL.toString().endsWith(workerScriptURL)) {
        console.log('Waiting for worker...');
        await new Promise(r => setTimeout(r, 300));
    }
    worker = workerReg.active;
    console.log('Worker activated');
    return worker;
}

async function checkOverlay()
{
    let path = document.location.pathname;
    let overlayURL = null;
    let baseURL = null;
    for (overlayPath in overlays) {
        if (path.startsWith(overlayPath)) {
            baseURL = document.location.origin + overlayPath;
            overlayURL = overlays[overlayPath];
        }
    }
    if (!overlayURL) {
        console.log('Not in overlay');
        return;
    }
    console.log(overlayURL);

    workerReg = await navigator.serviceWorker.register(workerScriptURL, {
        scope: workerScope
    });

    let worker = await getWorker();

    navigator.serviceWorker.addEventListener('message', e => {
        console.log(`Message from worker type ${e.data.type}, status ${e.data.status}`);
        if (workerResponseListener) {
            let f = workerResponseListener;
            workerResponseListener = null;
            f(e);
        }
    });

    /*let currentOverlayURL = await new Promise((resolve, reject) => {
        workerResponseListener = e => {
            if (e.data.status == 'ok') {
                resolve(e.data.id);
            } else {
                reject(new Error(e.data.message));
            }
        }
        worker.postMessage({ type: 'get' });
    });*/

    let status = await new Promise((resolve, reject) => {
        workerResponseListener = e => {
            if (e.data.status != 'error') {
                resolve(e.data.status);
            } else {
                reject(new Error(e.data.message));
            }
        }
        worker.postMessage({ type: 'set', id: overlayURL });
    });

    if (status == 'already') {
        console.log('Overlay already loaded. This is truly 404 error.');
        return;
    } else if (status == 'cached') {
        console.log('Overlay restored from cached. Reloading...');
        document.location.reload();
        return;
    }

    let overlay = await new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", overlayURL, true);
        xhr.responseType = 'arraybuffer';
        xhr.addEventListener('load', function () {
            if (xhr.status === 200) {
                resolve(xhr.response);
            } else {
                console.log(xhr.status);
                reject(Error("Download error!"));
            }
        })
        xhr.addEventListener('progress', function (e) {
            console.log(e.loaded);
        })
        xhr.send();
    });

    status = await new Promise((resolve, reject) => {
        workerResponseListener = e => {
            if (e.data.status != 'error') {
                resolve(e.data.status);
            } else {
                reject(new Error(e.data.message));
            }
        }
        worker.postMessage({ type: 'set', id: overlayURL, baseURL: baseURL, content: overlay }, [overlay]);
    });

    document.location.reload();

}

checkOverlay();

</script>

...

</body></html>